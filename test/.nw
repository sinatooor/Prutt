
@ 
\title{Akustisk källlokalisering och optimering i slutna rum:\\ En invers problemansats}
\author{
Sina Rajaeeian, Malte Bandmann
}

\date{November 2024}

\maketitle
\tableofcontents
\pagebreak

\section{Server4713}
<<Server4713.java>>=
/*******************************************
OBS! No swedish letters in this program.
STEN, SAX and PASE is played.
STEN = ROCK, SAX = SCISSORS, PASE = PAPER
*******************************************/
import java.net.*;
import java.io.*;
import java.util.*;
public class Server4713 {
    public static void main( String[] args) {
	try {
	    ServerSocket sock = new ServerSocket(4713,100);
	    while (true) 
		new ClientHandler(sock.accept()).start(); ///It’s a blocking method, it makes the program pause and wait until a client connects to the server, then it returns a socket
		
	}
	catch(IOException e)
	    {System.err.println(e);
	}
    }
} 

class ClientHandler extends Thread {
    static int numberOfPls=0;
    BufferedReader in;
    PrintWriter out;
    public ClientHandler(Socket socket){
	try {
	    in = new BufferedReader(new InputStreamReader
				    (socket.getInputStream()));
	    out= new PrintWriter(socket.getOutputStream());
	}
	catch(IOException e) {System.err.println(e);
	}
    }
    
    public void run() {
	Random random=new Random();
	String[] hand={"STEN","SAX","PASE"};
	try {
	    String name=in.readLine();
	    System.out.println((++numberOfPls)+": "+name);
            out.println("Hello, "+name);
            out.flush();
	    while(true) {
		String input = in.readLine();
		if(input==null || input.equals("")) break;
		out.println(hand[random.nextInt(3)]);
		out.flush();
	    }
	    out.println("Bye " + name); out.flush();
	    System.out.println(name + " stopped playing");
	    numberOfPls--;
	}
        catch(Exception e) {
	    System.err.println(e);
	}
    }
}

@
\section{RPSModel}

<<RPSModel.java>>=
import java.io.*;
import java.net.*;

public class RPSModel {
    private Socket socket;
    private BufferedReader in;
    private PrintWriter out;

    public RPSModel() {
        // Anslut till servern
        try {
            socket = new Socket("localhost", 4713);
            in = new BufferedReader(new InputStreamReader(socket.getInputStream()));
            out = new PrintWriter(socket.getOutputStream(), true);

            // Skicka ditt namn till servern
            out.println("Spelare");
            out.flush();

            // Läs serverns hälsning
            String response = in.readLine();
            System.out.println("Servern: " + response);
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    // Skicka spelarens drag till servern och få serverns drag
    public String getServerMove(String playerMove) {
        out.println(playerMove);
        out.flush();
        try {
            String serverMove = in.readLine();
            return serverMove;
        } catch (IOException e) {
            e.printStackTrace();
            return null;
        }
    }

    // Stäng anslutningen
    public void closeConnection() {
        try {
            out.println("");
            out.flush();
            in.close();
            out.close();
            socket.close();
        } catch (IOException ex) {
            ex.printStackTrace();
        }
    }

    // Metod för att avgöra vinnaren
    public String[] determineWinner(String playerMove, String serverMove) {
        if (playerMove.equals(serverMove)) {
            return new String[] {"Oavgjort!", "Oavgjort!"};
        } else if ((playerMove.equals("STEN") && serverMove.equals("SAX")) ||
                   (playerMove.equals("SAX") && serverMove.equals("PASE")) ||
                   (playerMove.equals("PASE") && serverMove.equals("STEN"))) {
            return new String[] {"Du vann!", "Du förlorade!"};
        } else {
            return new String[] {"Du förlorade!", "Du vann!"};
        }
    }
}

@
\section{RPSSkel}

<<RPSSkel.java>>=
import java.awt.*;
import java.awt.event.*;
import javax.swing.*;
import java.net.*;
import java.io.*;
import java.util.*;


public class RPSSkel extends JFrame implements ActionListener {
    Gameboard myboard, computersboard;
    JButton closebutton;
    int counter = 0; // För att räkna ETT... TVÅ... TRE
    RPSModel model;

    public RPSSkel() {
        super("Malte&Sina"); //sätter titel
        model = new RPSModel();

        setDefaultCloseOperation(EXIT_ON_CLOSE);
        closebutton = new JButton("Avsluta");

        // Skapa spelplaner
        myboard = new Gameboard("Sina&Malte", this); // 'this' är lyssnare för spelknapparna
        computersboard = new Gameboard("Datorn");

        // Lägg till spelplanerna i en panel
        JPanel boards = new JPanel();
        boards.setLayout(new GridLayout(1, 2));
        boards.add(myboard);
        boards.add(computersboard);

        // Lägg till lyssnare för Avsluta
        closebutton.addActionListener(new ActionListener() {
            public void actionPerformed(ActionEvent e) {
                model.closeConnection();
                System.exit(0);
            }
        });

        // Lägg till komponenterna till ramen
        add(boards, BorderLayout.CENTER);
        add(closebutton, BorderLayout.SOUTH);

        setSize(350, 650);
        setVisible(true);
    }

    // Implementera actionPerformed för spelknapparna
    public void actionPerformed(ActionEvent e) {
        String command = e.getActionCommand();
        counter++;

        //logiken för spelet och hur man vinner
        if (counter == 1) {
            myboard.resetColor();
            computersboard.resetColor();
            myboard.setLower("ETT...");
            computersboard.setLower("ETT...");
        } else if (counter == 2) {
            myboard.setLower("TVÅ...");
            computersboard.setLower("TVÅ...");
        } else if (counter == 3) {
            // Registrera spelarens drag
            myboard.markPlayed(command);
            myboard.setUpper(command);

            // Skicka spelarens drag till servern och få serverns drag
            String serverMove = model.getServerMove(command);

            // Visa serverns drag
            computersboard.markPlayed(serverMove);
            computersboard.setUpper(serverMove);

            // Avgör vinnaren
            String[] result = model.determineWinner(command, serverMove);

            // Uppdatera resultat
            myboard.setLower(result[0]);
            computersboard.setLower(result[1]);

            // Uppdatera poäng
            if (result[0].equals("Du vann!")) {
                myboard.wins();
            } else if (result[0].equals("Du förlorade!")) {
                computersboard.wins();
            }

            counter = 0; // Återställ räknaren
        }
    }

    public static void main(String[] args) {
        new RPSSkel();
    }
}

@
\section{Gameboard}

<<Gameboard.java>>=
import java.util.*;
import java.awt.*;
import java.awt.event.*;
import javax.swing.*;
class Gameboard extends JPanel {
	
    private Icon[] icons = {new ImageIcon("rock.gif"), 
		    new ImageIcon("paper.gif"),
		    new ImageIcon("scissors.gif")};

    private JButton[] buttons = new JButton[3];
    private JButton lastPlayed; // remembers last chosen button/gesture
    private String[] texts = {"STEN", "PASE", "SAX"};
    private JLabel upperMess, lowerMess, scorelabel;
    private int score;
    private Color bgcolor;
    private HashMap<String,JButton> map = new HashMap<String,JButton>(); // HashMap för att koppla gesternas text till motsvarande knapp


    // Constructor that builds the board, used for computers board
    Gameboard(String name) {
		setLayout(new GridLayout(5,1));

		// Upper JPanel holds players name and last gesture played
		JPanel upper = new JPanel();
		upper.setLayout(new GridLayout(2,1));
		upper.add(new JLabel(name, JLabel.CENTER)); 
		upperMess = new JLabel("RPS", JLabel.CENTER);
		upper.add(upperMess);
		add(upper);

		// Lower JPanel has messages about the game and score
		JPanel lower = new JPanel();
		lower.setLayout(new GridLayout(2,1));
		lowerMess = new JLabel("börja spela", JLabel.CENTER);
		scorelabel = new JLabel("Score: 0", JLabel.CENTER);
		lower.add(lowerMess); lower.add(scorelabel);

		for (int i = 0; i<3; i++){
			buttons[i] = new JButton(icons[i]);
			buttons[i].setActionCommand(texts[i]); //sätter actionCommand för varje knapp till sten sax pase
			add(buttons[i]);
			// Store each button in a map with its text as key. 
				// Enables us to retrieve the button from a textvalue. 
			map.put(texts[i],buttons[i]);
		}

		add(lower); // added after buttons
		bgcolor = buttons[0].getBackground();
		lastPlayed = buttons[0]; // arbitrary value at start
    }


    // Contructor for players board, puts listener on buttons
    Gameboard(String name, ActionListener listener) {
		this(name); // call other constructor to build the board
		
		for (int i = 0; i<3; i++) // Lägg till action-lyssnaren till varje knapp så att de kan reagera på klick
			buttons[i].addActionListener(listener);
    }

    // reset yellow color
    void resetColor() {
		lastPlayed.setBackground(bgcolor);
    }

    void setUpper(String r) {
		upperMess.setText(r);
    }

    void setLower(String r) {
		lowerMess.setText(r);
    }

   // remember last chosen JButton and mark it yellow
    void markPlayed(String r) {
		lastPlayed = map.get(r); 
		lastPlayed.setBackground(Color.yellow);
    }

    // or use JButton as parameter
    void markPlayed(JButton b) {
		lastPlayed = b; 
		lastPlayed.setBackground(Color.yellow);
    }

    // add one point and display new score
    void wins() {
		score++;
		scorelabel.setText("Score: " + score);
    }
}